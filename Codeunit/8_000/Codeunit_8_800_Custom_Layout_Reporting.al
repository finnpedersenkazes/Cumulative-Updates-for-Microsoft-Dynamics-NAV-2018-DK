OBJECT Codeunit 8800 Custom Layout Reporting
{
  OBJECT-PROPERTIES
  {
    Date=26-04-18;
    Time=12:00:00;
    Version List=NAVW111.00.00.21836;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      TempBlobReqParamStore@1005 : TEMPORARY Record 99008535;
      ReportSelections@1009 : Record 77;
      CustomReportSelection@1004 : Record 9657;
      ReportLayoutSelection@1010 : Record 9651;
      TempNameValueBuffer@1016 : TEMPORARY Record 823;
      TempEmailNameValueBuffer@1022 : TEMPORARY Record 823;
      TempEraseFileNameValueBuffer@1020 : TEMPORARY Record 823;
      RequestPageParametersHelper@1119 : Codeunit 1530;
      FileManagement@1110 : Codeunit 419;
      ReportDataRecordRef@1111 : RecordRef;
      IteratorRecordRef@1015 : RecordRef;
      ReportDataIteratorFieldRef@1112 : FieldRef;
      IteratorJoinFieldRef@1113 : FieldRef;
      BalAcctTypeFieldRef@1024 : FieldRef;
      AcctTypeFieldRef@1023 : FieldRef;
      OutputType@1001 : 'Print,Preview,PDF,Email,Excel,Word,XML';
      SaveFolderMsg@1003 : TextConst 'DAN=V‘lg en mappe, hvor rapporter skal gemmes.;ENU=Select a folder to save reports to.';
      NotInitializedErr@1000 : TextConst 'DAN=Rapportdata ikke initialiseret.;ENU=Report data not initialized.';
      OutputNotSupportedErr@1012 : TextConst 'DAN=Den valgte resultatmetode underst›ttes ikke.;ENU=The chosen output method is not supported.';
      SMTPNotSetupErr@1002 : TextConst 'DAN=Hvis du vil sende som mail, skal du konfigurere SMTP.;ENU=To send as email, you must set up SMTP.';
      ReportingType@1014 : 'Object,Layout';
      ZipFileName@1017 : Text;
      ZipDownloadTxt@1019 : TextConst 'DAN=Allerapporter.zip;ENU=AllReports.zip';
      Path@1056 : Text;
      OutputFileBaseName@1013 : Text;
      Initialized@1057 : Boolean;
      ReportDataAndIteratorDiffer@1058 : Boolean;
      SupressOutput@1006 : Boolean;
      PrintRemaining@1007 : Boolean;
      OverrideOutput@1011 : Boolean;
      TestModeWebClient@1008 : Boolean;
      PathLengthErr@1018 : TextConst '@@@=%1: a file name, generated by the system;DAN=Filnavnet %1 er for langt og kan ikke bruges.;ENU=The file name %1 is too long and cannot be used.';
      ReportFormatNotSupportedErr@1021 : TextConst '@@@=%1 is the extension for the report.;DAN=Oprettelse af rapporter med formattypen %1 underst›ttes ikke.;ENU=Creation of report with format type %1 is not supported.';
      NoOutputErr@1025 : TextConst 'DAN=Der findes ingen data for de angivne rapportfiltre.;ENU=No data exists for the specified report filters.';
      AnyOutputExists@1026 : Boolean;
      LastUsedTxt@1027 : TextConst '@@@=Translation must match RequestPageLatestSavedSettingsName from Lang.resx;DAN=Seneste anvendte indstillinger og filtre;ENU=Last used options and filters';

    [External]
    PROCEDURE GetLayoutIteratorKeyFilter@22(VAR FilterRecordRef@1080 : RecordRef;VAR FilterRecordKeyFieldRef@1081 : FieldRef;CustomReportLayoutCode@1003 : Code[20]);
    VAR
      CustomReportSelection2@1058 : Record 9657;
      Filter@1083 : Text;
    BEGIN
      // Further filters the items in FilterRecordRef by restricting them only to items who have entries in the "* Report Selection" tables
      // This prevents us from iterating over items that aren't related to the custom layouts
      CustomReportSelection2.SETVIEW(CustomReportSelection.GETVIEW);

      // Set the filters on the "* Report Selection" table and iterate through
      CustomReportSelection2.SETRANGE("Custom Report Layout Code",CustomReportLayoutCode);

      IF CustomReportSelection2.FINDSET THEN
        REPEAT
          IF Filter <> '' THEN
            Filter := Filter + '|';
          Filter := STRSUBSTNO('%1%2',Filter,CustomReportSelection2."Source No.");
        UNTIL CustomReportSelection2.NEXT = 0;

      // Set the more restrictive filter
      SetNextGroupFilter(FilterRecordRef,FilterRecordKeyFieldRef,Filter)
    END;

    [Internal]
    PROCEDURE ProcessReport@43();
    VAR
      RequestPageParamsView@1000 : Text;
      FilterGroup@1001 : Integer;
      ReportProcFirstErrorText@1002 : Text;
    BEGIN
      // If we're not yet initialized, exit - data needs to be set up before reports can be run
      IF NOT Initialized THEN
        EXIT;

      CLEARLASTERROR;
      AnyOutputExists := TRUE;
      // Iterate through the selections and run the reports.
      IF ReportSelections.FINDSET THEN BEGIN
        AnyOutputExists := FALSE;
        REPEAT
          SetOutputType(ReportSelections."Report ID");

          CustomReportSelection.SETFILTER("Report ID",STRSUBSTNO('0|%1',ReportSelections."Report ID"));
          CustomReportSelection.SETRANGE(Usage,ReportSelections.Usage);

          PrintRemaining := FALSE;

          // If our report's data item and the 'join table' are the same, then set its filter from the request page.
          IF NOT ReportDataAndIteratorDiffer THEN BEGIN
            RequestPageParamsView := GetViewFromParameters(ReportSelections."Report ID",IteratorRecordRef.NUMBER);
            IteratorRecordRef.SETVIEW(RequestPageParamsView);
          END;

          FilterGroup := ReportDataRecordRef.FILTERGROUP;
          ReportDataRecordRef.FILTERGROUP(FindNextEmptyFilterGroup(ReportDataRecordRef)); // Set the request page filters separately to preserve the existing filters
          RequestPageParamsView := GetViewFromParameters(ReportSelections."Report ID",ReportDataRecordRef.NUMBER);
          ReportDataRecordRef.SETVIEW(RequestPageParamsView);
          ReportDataRecordRef.FILTERGROUP(FilterGroup);
          CASE OutputType OF
            OutputType::Email:
              BEGIN
                EVALUATE(
                  PrintRemaining,GetOptionValueFromRequestPage(GetRequestParametersText(ReportSelections."Report ID"),'PrintRemaining'));
                ProcessReportPerObject;
              END;
            OutputType::PDF,
            OutputType::Word,
            OutputType::Excel,
            OutputType::XML:
              ProcessReportPerObject;
            OutputType::Preview,
            OutputType::Print:
              ProcessReportPerLayout;
          END;
          IF (ReportProcFirstErrorText = '') AND (GETLASTERRORTEXT <> '') AND (GETLASTERRORTEXT <> NoOutputErr) THEN
            ReportProcFirstErrorText := GETLASTERRORTEXT;
        UNTIL ReportSelections.NEXT = 0;
      END;

      // Download the .zip file containing the reports if one was generated (usually from being on the web client)
      IF (ZipFileName <> '') AND NOT SupressOutput AND TempNameValueBuffer.FINDSET THEN
        // If there's a single file, download it directly instead of the zip file
        IF TempNameValueBuffer.COUNT = 1 THEN
          IF IsTestMode THEN
            FileManagement.CopyServerFile(
              TempNameValueBuffer.Value,FileManagement.CombinePath(Path,TempNameValueBuffer.Name),TRUE)
          ELSE
            FileManagement.DownloadHandler(TempNameValueBuffer.Value,'','','',TempNameValueBuffer.Name)
        ELSE BEGIN
          REPEAT
            FileManagement.AddFileToZipArchive(TempNameValueBuffer.Value,TempNameValueBuffer.Name);
            TempEraseFileNameValueBuffer.AddNewEntry(TempNameValueBuffer.Value,'');
          UNTIL TempNameValueBuffer.NEXT = 0;
          FileManagement.CloseZipArchive;
          // If we're in test mode, save the zip to the save path. Otherwise send to the client.
          IF IsTestMode THEN
            FileManagement.CopyServerFile(ZipFileName,FileManagement.CombinePath(Path,ZipDownloadTxt),TRUE)
          ELSE
            FileManagement.DownloadHandler(ZipFileName,'','','',ZipDownloadTxt);
        END;

      CleanupTempFiles;

      IF NOT (SupressOutput OR AnyOutputExists) THEN BEGIN
        IF ReportProcFirstErrorText <> '' THEN
          ERROR(ReportProcFirstErrorText);
        ERROR(NoOutputErr);
      END;
    END;

    [Internal]
    PROCEDURE ProcessReportForData@27(ReportSelectionUsage@1005 : Integer;VAR DataRecordRef@1004 : RecordRef;SourceJoinFieldName@1003 : Text;DataRecordJoinTable@1002 : Integer;IteratorTableFieldName@1001 : Text;DataItemTableSameAsIterator@1000 : Boolean);
    BEGIN
      // Provides a single function to run initialization code, check for issues, and start report processing
      IF NOT Initialized THEN
        InitializeData(
          ReportSelectionUsage,DataRecordRef,SourceJoinFieldName,DataRecordJoinTable,IteratorTableFieldName,
          DataItemTableSameAsIterator);
      // If there was an error during initalization, exit
      IF NOT Initialized THEN
        EXIT;
      ProcessReport;
    END;

    LOCAL PROCEDURE ProcessReportPerLayout@7();
    VAR
      ReportedLayouts@1086 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Collections.ArrayList";
      ReportedObjects@1087 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Collections.ArrayList";
      TempRecordRef@1000 : RecordRef;
      TempRecordKeyFieldRef@1088 : FieldRef;
      CustomReportLayoutCode@1089 : Code[20];
      ReportedRecordKeyVal@1091 : Text;
    BEGIN
      ReportingType := ReportingType::Layout;
      // Prevent early calls to the function
      IF NOT Initialized THEN
        ERROR(NotInitializedErr);

      // Temporary lists to keep track of what we've reported over, used to determine what to report on using the default layout
      ReportedLayouts := ReportedLayouts.ArrayList;
      ReportedObjects := ReportedObjects.ArrayList;

      // Iterate through the layouts in the Custom Report Selection table
      IF CustomReportSelection.FINDSET THEN BEGIN
        REPEAT
          CustomReportLayoutCode := CustomReportSelection."Custom Report Layout Code";

          // Reset the TempRecordRef object
          TempRecordRef := ReportDataRecordRef.DUPLICATE;
          TempRecordKeyFieldRef := TempRecordRef.FIELD(ReportDataIteratorFieldRef.NUMBER);

          // If we've not already reported on this layout and it truly is a custom layout, then report on it
          IF NOT ReportedLayouts.Contains(CustomReportLayoutCode) AND
             (ResolveCustomReportLayoutCode(CustomReportSelection) <> '')
          THEN BEGIN
            ReportedLayouts.Add(CustomReportLayoutCode);

            // Run the report only for those objects that have this layout
            GetLayoutIteratorKeyFilter(TempRecordRef,TempRecordKeyFieldRef,CustomReportLayoutCode); // set view based on intersection of lists

            // Run the report on the data record, using the above filter
            RunReportWithCustomReportSelection(TempRecordRef,ReportSelections."Report ID",CustomReportSelection,PrintRemaining);

            // Save this list of objects reported on, using the 'iterator field', they will not get the default report layout later
            IF TempRecordRef.FINDFIRST THEN
              REPEAT
                ReportedRecordKeyVal := FORMAT(TempRecordKeyFieldRef.VALUE);
                IF NOT ReportedObjects.Contains(ReportedRecordKeyVal) THEN
                  ReportedObjects.Add(ReportedRecordKeyVal);
              UNTIL TempRecordRef.NEXT = 0;
          END;
        UNTIL CustomReportSelection.NEXT = 0;
      END;

      // Construct the filter for the remaining objects - iterate through all items in the data record and build a filter that contains the
      // items that are not in the list of already reported items.
      TempRecordRef := ReportDataRecordRef.DUPLICATE;
      TempRecordKeyFieldRef := TempRecordRef.FIELD(ReportDataIteratorFieldRef.NUMBER);

      // Set the exclusion filter based on the items we've already reported on and set that filter on top of the filter already applied
      IF TempRecordRef.FINDFIRST THEN
        REPEAT
          IF ReportedObjects.Contains(FORMAT(TempRecordKeyFieldRef.VALUE)) THEN
            SetNextGroupFilter(TempRecordRef,TempRecordKeyFieldRef,STRSUBSTNO('<>%1',FORMAT(TempRecordKeyFieldRef.VALUE)));
        UNTIL TempRecordRef.NEXT = 0;

      // Only run the report if we still have something to report on
      IF TempRecordRef.FINDFIRST THEN
        RunReport(TempRecordRef,ReportSelections."Report ID",PrintRemaining);
    END;

    LOCAL PROCEDURE ProcessReportPerObject@21();
    VAR
      PrevRecordID@1003 : RecordID;
      IteratorJoinFieldValue@1095 : Code[20];
      ReportID@1096 : Integer;
      IteratorFilterGroup@1000 : Integer;
      JoinValue@1001 : Code[20];
    BEGIN
      ReportingType := ReportingType::Object;
      IF NOT Initialized THEN
        ERROR(NotInitializedErr);

      ReportID := ReportSelections."Report ID";

      EVALUATE(IteratorJoinFieldValue,FORMAT(IteratorJoinFieldRef.VALUE));

      // Set the data filter to be the item we're iterating over:

      IF ReportDataRecordRef.FINDSET THEN BEGIN
        REPEAT
          // Get and set the report selection for this particular object/report combination
          JoinValue := FORMAT(ReportDataIteratorFieldRef.VALUE,20);
          CustomReportSelection.SETRANGE("Source No.",JoinValue);
          IteratorFilterGroup := SetNextGroupFilter(ReportDataRecordRef,ReportDataIteratorFieldRef,JoinValue);
          PrevRecordID := ReportDataRecordRef.RECORDID;

          SetIteratorJoinFieldRef;
          // Find the 'join' value in the associated table, this helps us generate the name
          IteratorJoinFieldRef.SETRANGE(JoinValue);
          IteratorRecordRef.FINDFIRST;

          // If the object has custom layouts defined - process each one based on the selected output type, otherwise use the default layout
          IF CustomReportSelection.FINDSET THEN
            REPEAT
              RunReportWithCustomReportSelection(ReportDataRecordRef,ReportID,CustomReportSelection,PrintRemaining);
            UNTIL CustomReportSelection.NEXT = 0
          ELSE
            RunReport(ReportDataRecordRef,ReportID,PrintRemaining);

          // Clear out the filter and reset:
          SetGroupFilter(ReportDataRecordRef,ReportDataIteratorFieldRef,'',IteratorFilterGroup);
          ReportDataRecordRef.GET(PrevRecordID);

        UNTIL ReportDataRecordRef.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE RunReportWithCustomReportSelection@24(VAR DataRecRef@1000 : RecordRef;ReportID@1001 : Integer;VAR CustomReportSelection@1002 : Record 9657;EmailPrintRemaining@1003 : Boolean);
    VAR
      CustomReportLayoutCode@1005 : Code[20];
      EmailAddresses@1096 : Text;
    BEGIN
      // Set the custom report layout
      CustomReportLayoutCode := ResolveCustomReportLayoutCode(CustomReportSelection);
      ReportLayoutSelection.SetTempLayoutSelected(CustomReportLayoutCode);

      // Get the email address of the current object-specific report selection
      EmailAddresses := CustomReportSelection."Send To Email";
      CASE OutputType OF
        OutputType::Email:
          IF EmailAddresses <> '' THEN
            EmailReport(DataRecRef,ReportID,CustomReportSelection)
          ELSE
            IF EmailPrintRemaining THEN
              PrintReport(DataRecRef,ReportID,CustomReportLayoutCode);
        OutputType::PDF:
          SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Pdf);
        OutputType::Excel:
          SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Excel);
        OutputType::Word:
          SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Word);
        OutputType::Print:
          PrintReport(DataRecRef,ReportID,CustomReportLayoutCode);
        OutputType::Preview:
          PreviewReport(DataRecRef,ReportID,CustomReportLayoutCode);
        OutputType::XML:
          SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Xml);
      END;
      IF CustomReportLayoutCode <> '' THEN
        ReportLayoutSelection.SetTempLayoutSelected('');
    END;

    LOCAL PROCEDURE RunReport@25(VAR DataRecRef@1003 : RecordRef;ReportID@1002 : Integer;EmailPrintRemaining@1000 : Boolean);
    VAR
      NullCustomReportSelection@1004 : Record 9657;
    BEGIN
      // If we know we don't need a custom report selection, e.g. we don't need layouts or won't be sending email
      NullCustomReportSelection.INIT;
      RunReportWithCustomReportSelection(DataRecRef,ReportID,NullCustomReportSelection,EmailPrintRemaining);
    END;

    [External]
    PROCEDURE SetOutputOption@26(OutputOption@1000 : Integer);
    BEGIN
      OutputType := OutputOption;
    END;

    [Internal]
    PROCEDURE GetOutputOption@1(ReportID@1002 : Integer) : Integer;
    VAR
      OptionText@1001 : Text;
      OptionInt@1000 : Integer;
    BEGIN
      // Given a report ID, get the currently selected output option
      OptionText := GetOptionValueFromRequestPageForReport(ReportID,'ChosenOutputMethod');
      IF EVALUATE(OptionInt,OptionText) THEN
        EXIT(OptionInt);

      EXIT(-1); // Invalid output option, still a valid return code - signals no output
    END;

    [External]
    PROCEDURE GetPrintOption@3() : Integer;
    BEGIN
      EXIT(OutputType::Print);
    END;

    [External]
    PROCEDURE GetEmailOption@4() : Integer;
    BEGIN
      EXIT(OutputType::Email);
    END;

    [External]
    PROCEDURE GetPreviewOption@5() : Integer;
    BEGIN
      EXIT(OutputType::Preview);
    END;

    [External]
    PROCEDURE GetExcelOption@6() : Integer;
    BEGIN
      EXIT(OutputType::Excel);
    END;

    [External]
    PROCEDURE GetPDFOption@8() : Integer;
    BEGIN
      EXIT(OutputType::PDF);
    END;

    [External]
    PROCEDURE GetWordOption@13() : Integer;
    BEGIN
      EXIT(OutputType::Word);
    END;

    [External]
    PROCEDURE GetXMLOption@30() : Integer;
    BEGIN
      EXIT(OutputType::XML);
    END;

    LOCAL PROCEDURE PrintReport@12(VAR DataRecRef@1003 : RecordRef;ReportID@1002 : Integer;CustomReportLayoutCode@1000 : Code[20]);
    BEGIN
      // If the print action is selected and we're on the web, shunt over to PDF output and ZIP file download
      IF IsWebClient AND NOT IsWordLayout(ReportID,CustomReportLayoutCode) THEN
        SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Pdf);

      // If we're on the web client, and Word layout, then run the default
      IF IsWebClient AND IsWordLayout(ReportID,CustomReportLayoutCode) THEN
        SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Word);

      // Local client - print
      IF NOT IsWebClient AND NOT SupressOutput THEN BEGIN
        REPORT.PRINT(ReportID,GetRequestParametersText(ReportID),'',DataRecRef);
        AnyOutputExists := TRUE;
      END;
    END;

    LOCAL PROCEDURE EmailReport@11(VAR DataRecRef@1004 : RecordRef;ReportID@1003 : Integer;CustomReportSelection@1002 : Record 9657);
    VAR
      FieldRef1@1014 : FieldRef;
      FieldRef2@1013 : FieldRef;
      ReportRecordVariant@1012 : Variant;
      TempPdfFilePath@1009 : Text[250];
      TempEmailBodyFilePath@1008 : Text[250];
      FileName@1005 : Text[250];
      PdfFileName@1006 : Text[250];
      TempReportLayoutCode@1001 : Code[20];
      EmailBodyLayoutCode@1000 : Code[20];
    BEGIN
      TempPdfFilePath := CreateReportWithExtension(DataRecRef,ReportID,REPORTFORMAT::Pdf,FileName);
      IF TempPdfFilePath = '' THEN
        EXIT;

      // Set the pdf file name to be used later when sending an email.
      PdfFileName := FileName;

      // Use the iterator values if the data item and iterator differ
      IF ReportDataAndIteratorDiffer THEN BEGIN
        GetKeyFieldRef(IteratorRecordRef,FieldRef1);
        GetNameFieldRef(IteratorRecordRef,FieldRef2);
      END ELSE BEGIN
        GetKeyFieldRef(DataRecRef,FieldRef1);
        GetNameFieldRef(DataRecRef,FieldRef2);
      END;

      EmailBodyLayoutCode := ResolveEmailBodyLayoutCode(CustomReportSelection,ReportSelections);
      IF EmailBodyLayoutCode <> '' THEN BEGIN
        TempReportLayoutCode := ReportLayoutSelection.GetTempLayoutSelected;
        ReportLayoutSelection.SetTempLayoutSelected(EmailBodyLayoutCode);
        ReportRecordVariant := DataRecRef;

        TempEmailBodyFilePath := CreateReportWithExtension(ReportRecordVariant,ReportID,REPORTFORMAT::Html,FileName);
        IF TempEmailBodyFilePath = '' THEN
          EXIT;
        ReportLayoutSelection.SetTempLayoutSelected(TempReportLayoutCode);
      END;

      IF SupressOutput OR RemoveEmptyFile(TempPdfFilePath) THEN
        EXIT;

      AnyOutputExists := TRUE;
      TryEmailReport(TempPdfFilePath,PdfFileName,TempEmailBodyFilePath,CustomReportSelection,FieldRef2);
    END;

    LOCAL PROCEDURE PreviewReport@10(VAR DataRecRef@1001 : RecordRef;ReportID@1000 : Integer;CustomReportLayoutCode@1006 : Code[20]);
    VAR
      File@1073 : File;
      FileStream@1074 : OutStream;
      FileName@1075 : Text;
      TempFilePath@1076 : Text;
      ReportSaved@1077 : Boolean;
    BEGIN
      IF IsWebClient OR IsWordLayout(ReportID,CustomReportLayoutCode) THEN BEGIN
        TempFilePath := FileManagement.ServerTempFileName('.docx');
        FileName := GenerateFileNameForReportLayout(ReportID,'.docx','');
        File.CREATE(TempFilePath);
        File.CREATEOUTSTREAM(FileStream);
        ReportSaved := REPORT.SAVEAS(ReportID,GetRequestParametersText(ReportID),REPORTFORMAT::Word,FileStream,DataRecRef);
        File.CLOSE;
        IF FileManagement.ServerFileExists(TempFilePath) AND ReportSaved AND NOT RemoveEmptyFile(TempFilePath) THEN
          AddFileToClientZip(TempFilePath,FileName);
      END ELSE
        IF NOT SupressOutput THEN BEGIN
          REPORT.EXECUTE(ReportID,GetRequestParametersText(ReportID),DataRecRef);
          AnyOutputExists := TRUE;
        END;
    END;

    LOCAL PROCEDURE SaveAsReport@9(VAR DataRecRef@1002 : RecordRef;ReportID@1000 : Integer;RepFormat@1059 : ReportFormat);
    VAR
      File@1077 : File;
      FileStream@1078 : OutStream;
      FileName@1079 : Text;
      Extension@1080 : Text;
      TempFilePath@1070 : Text;
      ReportSaved@1071 : Boolean;
      BasePath@1001 : Text;
    BEGIN
      // Handle both 'save file' types of reports together - PDF and Excel
      CASE RepFormat OF
        REPORTFORMAT::Excel:
          Extension := '.xlsx';
        REPORTFORMAT::Pdf:
          Extension := '.pdf';
        REPORTFORMAT::Word:
          Extension := '.docx';
        REPORTFORMAT::Xml:
          Extension := '.xml';
        ELSE
          ERROR(OutputNotSupportedErr);
      END;

      // If no path was given (often during test runs), use a temp directory on the server
      IF FileManagement.IsWindowsClient AND (Path = '') THEN
        Path := FileManagement.ServerCreateTempSubDirectory;

      // If we're not on the web client, use the path that was selected for saving
      // In the web client, the path isn't used since we zip up the files and send them to the client
      IF NOT IsWebClient THEN
        BasePath := Path;
      CASE ReportingType OF
        ReportingType::Object:
          FileName := GenerateFileNameForReport(ReportID,Extension,BasePath,TRUE);
        ReportingType::Layout:
          FileName := GenerateFileNameForReportLayout(ReportID,Extension,BasePath);
      END;

      TempFilePath := FileManagement.ServerTempFileName(Extension);
      File.CREATE(TempFilePath);
      File.CREATEOUTSTREAM(FileStream);
      ReportSaved := REPORT.SAVEAS(ReportID,GetRequestParametersText(ReportID),RepFormat,FileStream,DataRecRef);
      File.CLOSE;

      IF ReportSaved AND NOT RemoveEmptyFile(TempFilePath) AND FileManagement.ServerFileExists(TempFilePath) AND NOT SupressOutput THEN
        IF IsWebClient THEN
          AddFileToClientZip(TempFilePath,FileName)
        ELSE BEGIN
          FileManagement.DownloadToFile(TempFilePath,FileName);
          TempEraseFileNameValueBuffer.AddNewEntry(FORMAT(TempFilePath,250),'');
          AnyOutputExists := TRUE;
        END;
    END;

    LOCAL PROCEDURE GenerateFileNameForReport@2(ReportID@1005 : Integer;Extension@1001 : Text;FilePath@1002 : Text;IncludeLayoutName@1004 : Boolean) : Text[250];
    VAR
      NameFieldRef@1072 : FieldRef;
      ObjectName@1000 : Text;
      Caption@1003 : Text;
    BEGIN
      // If we're iterating through Customer or Vendor, get the appropriate name
      IF GetNameFieldRef(IteratorRecordRef,NameFieldRef) THEN
        ObjectName := STRSUBSTNO('%1',NameFieldRef.VALUE);

      IF IncludeLayoutName THEN BEGIN
        Caption := GetTempLayoutReportCaption(ReportID);
        ObjectName := STRSUBSTNO('%1_%2',ObjectName,Caption);
      END;

      EXIT(GenerateFileName(ObjectName,ReportID,Extension,FilePath));
    END;

    LOCAL PROCEDURE GenerateFileNameForReportLayout@31(ReportID@1005 : Integer;Extension@1001 : Text;FilePath@1002 : Text) : Text[250];
    BEGIN
      // Get report caption if we're not on a custom layout, otherwise get the custom layout caption
      EXIT(GenerateFileName(GetTempLayoutReportCaption(ReportID),ReportID,Extension,FilePath));
    END;

    LOCAL PROCEDURE GenerateFileName@32(ObjectName@1003 : Text;ReportID@1002 : Integer;Extension@1001 : Text;FilePath@1000 : Text) : Text;
    VAR
      FileName@1004 : Text;
      EndDate@1005 : Text;
      ReportParameters@1006 : Text;
    BEGIN
      ReportParameters := GetRequestParametersText(ReportID);

      IF STRPOS(Extension,'.') <> 1 THEN
        Extension := '.' + Extension;

      // We need to limit the file name - limit of other functions
      IF (STRLEN(ObjectName) + STRLEN(FilePath)) >= 250 THEN
        ObjectName := FORMAT(ObjectName,250 - STRLEN(FilePath));

      // Fetch request page parameters
      EndDate := GetOptionValueFromRequestPage(ReportParameters,'EndDate');

      // Construct with the end date, if it exists. Format the object name to adhere to filename size limits
      IF OutputFileBaseName = '' THEN
        OutputFileBaseName := 'Report';
      IF EndDate <> '' THEN
        FileName := OutputFileBaseName + ' for ' + ObjectName + ' as of ' + EndDate + Extension
      ELSE
        FileName := OutputFileBaseName + ' for ' + ObjectName + Extension;

      FileName := FileManagement.StripNotsupportChrInFileName(FileName);

      IF FilePath <> '' THEN
        FileName := FileManagement.CombinePath(FilePath,FileName);

      EXIT(FileName);
    END;

    LOCAL PROCEDURE GetOptionValueFromRequestPage@45(ReportParameters@1002 : Text;OptionName@1001 : Text) : Text;
    BEGIN
      EXIT(RequestPageParametersHelper.GetRequestPageOptionValue(OptionName,ReportParameters));
    END;

    PROCEDURE GetOptionValueFromRequestPageForReport@48(ReportID@1002 : Integer;OptionName@1001 : Text) : Text;
    BEGIN
      // Given a report ID - get the option from the request parameters page
      IF NOT TempBlobReqParamStore.GET(ReportID) THEN
        EXIT('');
      EXIT(GetOptionValueFromRequestPage(GetRequestParametersText(ReportID),OptionName));
    END;

    LOCAL PROCEDURE GetTempLayoutReportCaption@42(ReportID@1000 : Integer) : Text;
    VAR
      CustomReportLayout@1004 : Record 9650;
      AllObjWithCaption@1003 : Record 2000000058;
      ReportCaption@1002 : Text;
      CurrentCustomLayoutCode@1001 : Code[20];
    BEGIN
      CurrentCustomLayoutCode := ReportLayoutSelection.GetTempLayoutSelected;
      IF CurrentCustomLayoutCode = '' THEN BEGIN
        AllObjWithCaption.GET(AllObjWithCaption."Object Type"::Report,ReportID);
        ReportCaption := AllObjWithCaption."Object Caption";
      END ELSE BEGIN
        CustomReportLayout.GET(CurrentCustomLayoutCode);
        ReportCaption := CustomReportLayout.Description;
      END;
      EXIT(ReportCaption);
    END;

    [External]
    PROCEDURE SetSavePath@29(SavePath@1000 : Text);
    BEGIN
      // This allows us to set the path ahead of setting request parameters if we know it or need to set it ahead of time
      // e.g. for unit tests
      Path := SavePath;
    END;

    LOCAL PROCEDURE GetViewFromParameters@75(ReportID@1004 : Integer;TableNumber@1075 : Integer) : Text;
    VAR
      RecordRef@1005 : RecordRef;
    BEGIN
      TempBlobReqParamStore.GET(ReportID);
      TempBlobReqParamStore.SETRECFILTER;
      TempBlobReqParamStore.CALCFIELDS(Blob);
      // Use the request page helper to parse the parameters and set the view to the RecordRef and the Record
      RecordRef.OPEN(TableNumber);
      RequestPageParametersHelper.ConvertParametersToFilters(RecordRef,TempBlobReqParamStore);

      EXIT(RecordRef.GETVIEW);
    END;

    LOCAL PROCEDURE GetRequestParameters@23();
    VAR
      SMTPMailSetup@1001 : Record 409;
      DataVariant@1002 : Variant;
      TempReqParams@1000 : Text;
      FilterGroup@1003 : Integer;
    BEGIN
      ReportSelections.SETFILTER("Report ID",'<>0');
      ReportSelections.FINDFIRST;

      IF ReportSelections.FINDSET THEN
        REPEAT
          // If we're at this point, and we're set in test mode with XML output - run the report directly from here
          // This is done to retain compatibility with report testing (which uses RequestPage.SaveAsXML and needs the traditional output options buttons)
          // XML output can't use the layouts anyways.
          IF IsTestMode AND OverrideOutput AND (OutputType = OutputType::XML) THEN BEGIN
            DataVariant := ReportDataRecordRef;
            REPORT.RUNMODAL(ReportSelections."Report ID",TRUE,FALSE,DataVariant);
            ERROR(''); // Exit early in an uninitialized state, prevents the full initialization flag from being set
          END;
          COMMIT;
          TempReqParams :=
            REPORT.RUNREQUESTPAGE(ReportSelections."Report ID",GetReportRequestPageParameters(ReportSelections."Report ID"));
          // If the user cancelled out of the request page - exclude this report ID from processing:
          IF TempReqParams = '' THEN BEGIN
            // Advance to the next open filtergroup outside of the system range
            FilterGroup := ReportSelections.FILTERGROUP;
            IF ReportSelections.HASFILTER OR (ReportSelections.FILTERGROUP < 10) THEN
              REPEAT
                ReportSelections.FILTERGROUP(ReportSelections.FILTERGROUP + 1)
              UNTIL NOT ReportSelections.HASFILTER AND (ReportSelections.FILTERGROUP >= 10);
            ReportSelections.SETFILTER("Report ID",STRSUBSTNO('<>%1',ReportSelections."Report ID"));
            ReportSelections.FILTERGROUP(FilterGroup);
            BREAK;
          END;

          StoreRequestParameters(TempReqParams);
          SaveReportRequestPageParameters(ReportSelections."Report ID",TempReqParams);
          // Validate output type and get a file save path, if necessary, only prompt for windows clients that are not in test mode
          SetOutputType(ReportSelections."Report ID");
          IF FileManagement.IsWindowsClient AND (Path = '') AND (NOT IsTestMode) AND
             (OutputType IN [OutputType::PDF,OutputType::Excel,OutputType::Word,OutputType::XML])
          THEN
            FileManagement.SelectFolderDialog(SaveFolderMsg,Path);

          // Use the temp path if we're set in test mode and the path wasn't already set
          IF (Path = '') AND IsTestMode THEN
            Path := TEMPORARYPATH;

          // If email is chosen, ensure that SMTP is set up
          IF (OutputType = OutputType::Email) AND NOT SMTPMailSetup.FINDFIRST AND NOT SupressOutput THEN
            ERROR(SMTPNotSetupErr);
        UNTIL ReportSelections.NEXT = 0;

      Initialized := TRUE;
    END;

    LOCAL PROCEDURE SetOutputType@33(ReportID@1002 : Integer);
    VAR
      OutputMethod@1000 : Text;
      OptionInt@1001 : Integer;
    BEGIN
      // Don't set based on the report ID if we're overriding the output type (for tests, output-specific functions)
      IF OverrideOutput THEN
        EXIT;
      // The request page should have the appropriate parameters set for the chosen output method
      OutputMethod := GetOptionValueFromRequestPage(GetRequestParametersText(ReportID),'ChosenOutputMethod');
      IF OutputMethod <> '' THEN BEGIN
        IF NOT EVALUATE(OptionInt,OutputMethod) THEN
          ERROR(OutputNotSupportedErr);
      END ELSE
        ERROR(OutputNotSupportedErr);

      SetOutputOption(OptionInt);
    END;

    LOCAL PROCEDURE SetReportUsage@37(ReportSelectionUsage@1000 : Integer);
    BEGIN
      ReportSelections.SETRANGE(Usage,ReportSelectionUsage);
      CustomReportSelection.SETRANGE(Usage,ReportSelectionUsage);
    END;

    [External]
    PROCEDURE SetOutputSupression@14(SupressOutputFlag@1000 : Boolean);
    BEGIN
      SupressOutput := SupressOutputFlag;
    END;

    LOCAL PROCEDURE StoreRequestParameters@15(Parameters@1000 : Text);
    VAR
      OutStr@1001 : OutStream;
      ReportID@1002 : Integer;
    BEGIN
      EVALUATE(ReportID,RequestPageParametersHelper.GetReportID(Parameters));
      // Insert or Modify - based on if it exists already or not
      IF TempBlobReqParamStore.GET(ReportID) THEN BEGIN
        TempBlobReqParamStore.Blob.CREATEOUTSTREAM(OutStr);
        OutStr.WRITETEXT(Parameters);
        TempBlobReqParamStore.MODIFY;
      END ELSE BEGIN
        TempBlobReqParamStore.INIT;
        TempBlobReqParamStore.Blob.CREATEOUTSTREAM(OutStr);
        OutStr.WRITETEXT(Parameters);
        TempBlobReqParamStore."Primary Key" := ReportID;
        TempBlobReqParamStore.INSERT;
      END;
      COMMIT;
    END;

    LOCAL PROCEDURE GetRequestParametersText@19(ReportID@1000 : Integer) : Text;
    VAR
      InStr@1001 : InStream;
      ReqPageXML@1004 : Text;
    BEGIN
      TempBlobReqParamStore.GET(ReportID);
      TempBlobReqParamStore.CALCFIELDS(Blob);
      TempBlobReqParamStore.Blob.CREATEINSTREAM(InStr);
      InStr.READTEXT(ReqPageXML);
      EXIT(ReqPageXML);
    END;

    LOCAL PROCEDURE AddFileToClientZip@82(TempFileName@1000 : Text;ClientFileName@1001 : Text);
    BEGIN
      IF STRLEN(TempFileName) > 250 THEN
        ERROR(STRSUBSTNO(PathLengthErr,TempFileName));

      IF STRLEN(ClientFileName) > 250 THEN
        ERROR(STRSUBSTNO(PathLengthErr,ClientFileName));

      // Ensure we have a zip file object
      IF ZipFileName = '' THEN
        ZipFileName := FileManagement.CreateZipArchiveObject;

      TempNameValueBuffer.SETRANGE(Name,COPYSTR(ClientFileName,1,250));
      IF NOT TempNameValueBuffer.FINDFIRST THEN
        TempNameValueBuffer.AddNewEntry(COPYSTR(ClientFileName,1,250),COPYSTR(TempFileName,1,250));

      AnyOutputExists := TRUE;
    END;

    LOCAL PROCEDURE IsWordLayout@88(ReportID@1000 : Integer;CustomReportLayoutCode@1001 : Code[20]) : Boolean;
    VAR
      CustomReportLayout@1002 : Record 9650;
    BEGIN
      IF CustomReportLayoutCode <> '' THEN BEGIN
        CustomReportLayout.Code := CustomReportLayoutCode;
        IF CustomReportLayout.FIND('=') THEN
          EXIT(CustomReportLayout.Type = CustomReportLayout.Type::Word);

        EXIT(REPORT.DEFAULTLAYOUT(ReportID) = DEFAULTLAYOUT::Word);
      END;
      EXIT(REPORT.DEFAULTLAYOUT(ReportID) = DEFAULTLAYOUT::Word)
    END;

    LOCAL PROCEDURE SetReportDataItem@1051(VAR DataRecordRef@1065 : RecordRef;SourceJoinFieldName@1066 : Text;DataRecordJoinTable@1067 : Integer;IteratorTableFieldName@1069 : Text;DataItemTableSameAsIterator@1068 : Boolean);
    VAR
      ConfigValidateManagement@1076 : Codeunit 8617;
      RelationTable@1077 : Integer;
      RelationField@1079 : Integer;
      i@1078 : Integer;
    BEGIN
      // Copy the RecordRef so as to not disturb the original
      ReportDataRecordRef := DataRecordRef.DUPLICATE;

      // Find the fields that relate the iterator to the data record - based on caption:
      FOR i := 1 TO ReportDataRecordRef.FIELDCOUNT DO
        IF ReportDataRecordRef.FIELDEXIST(i) THEN
          IF ReportDataRecordRef.FIELD(i).NAME = SourceJoinFieldName THEN BEGIN
            ReportDataIteratorFieldRef := ReportDataRecordRef.FIELD(i);
            BREAK;
          END;
      // If the tables are different, 'join' using the filter of the data item passed in.
      IF DataItemTableSameAsIterator THEN BEGIN
        IteratorRecordRef.OPEN(ReportDataRecordRef.NUMBER);
        IteratorJoinFieldRef := IteratorRecordRef.FIELD(ReportDataIteratorFieldRef.NUMBER);
        SetNextGroupFilter(IteratorRecordRef,IteratorJoinFieldRef,ReportDataIteratorFieldRef.GETFILTER);
        ReportDataAndIteratorDiffer := FALSE;
      END ELSE BEGIN
        ConfigValidateManagement.GetRelationInfoByIDs(
          ReportDataRecordRef.NUMBER,ReportDataIteratorFieldRef.NUMBER,RelationTable,RelationField);
        IteratorRecordRef.OPEN(DataRecordJoinTable);
        FOR i := 1 TO IteratorRecordRef.FIELDCOUNT DO
          IF IteratorRecordRef.FIELD(i).NAME = IteratorTableFieldName THEN BEGIN
            IteratorJoinFieldRef := IteratorRecordRef.FIELD(i);
            BREAK;
          END;
        ReportDataAndIteratorDiffer := TRUE;
      END;

      CustomReportSelection.SETRANGE("Source Type",IteratorRecordRef.NUMBER);
    END;

    LOCAL PROCEDURE RemoveEmptyFile@1050(FileName@1060 : Text) : Boolean;
    VAR
      File@1061 : File;
    BEGIN
      // This function cleans up empty files, allowing us to remove reports that do not save correctly or error out/have no output.
      File.OPEN(FileName);
      IF File.LEN = 0 THEN BEGIN
        File.CLOSE;
        ERASE(FileName);
        EXIT(TRUE);
      END;
      File.CLOSE;
      EXIT(FALSE);
    END;

    PROCEDURE IsWebClient@18() : Boolean;
    BEGIN
      IF TestModeWebClient THEN
        EXIT(TRUE);
      EXIT(FileManagement.IsWebClient);
    END;

    PROCEDURE SetOutputFileBaseName@20(FileBaseName@1000 : Text);
    BEGIN
      // Sets a text base name for the output files:
      // e.g. code calling reports with usage of 'Statement' would set 'Statement' here
      OutputFileBaseName := FileBaseName;
    END;

    [Normal]
    [Internal]
    PROCEDURE SetTestMode@35(TestMode@1000 : Boolean);
    VAR
      TempBlob@1002 : Record 99008535;
      BlobOutStream@1001 : OutStream;
    BEGIN
      // Sets test mode for this codeunit - enables unit test scenarios
      TempBlob.INIT;
      TempBlob.RESET;
      TempBlob."Primary Key" := CODEUNIT::"Custom Layout Reporting";
      IF TempBlob.FIND THEN
        TempBlob.DELETE;

      TempBlob.Blob.CREATEOUTSTREAM(BlobOutStream);
      BlobOutStream.WRITETEXT(FORMAT(TestMode));
      TempBlob.INSERT;
      COMMIT;

      OverrideOutput := TestMode;
    END;

    LOCAL PROCEDURE IsTestMode@36() : Boolean;
    VAR
      TempBlob@1003 : Record 99008535;
      TestModeInStream@1002 : InStream;
      ReadText@1001 : Text[10];
      ReadBoolean@1000 : Boolean;
    BEGIN
      // Check to see if the test mode flag is set (usually via test codeunits before calling this codeunit directly)
      // Alternatively, check tempblob for a sentinel value (set via test codeunits that do not/cannot call this codeunit directly)
      ReadBoolean := FALSE;
      IF TempBlob.GET(8800) THEN BEGIN
        TempBlob.CALCFIELDS(Blob);
        TempBlob.Blob.CREATEINSTREAM(TestModeInStream);
        TestModeInStream.READTEXT(ReadText,10);
        EVALUATE(ReadBoolean,ReadText);
      END;
      EXIT(ReadBoolean);
    END;

    PROCEDURE SetTestModeWebClient@38(TestModeSpoofWebClient@1000 : Boolean);
    BEGIN
      TestModeWebClient := TestModeSpoofWebClient;
    END;

    LOCAL PROCEDURE ResolveCustomReportLayoutCode@46(VAR CustomReportSelection@1000 : Record 9657) : Code[20];
    BEGIN
      // Given a custom report selection, return the custom layout, unless report ID  = 0, then resolve to the appropriate company-wide layout for the report ID
      IF CustomReportSelection."Custom Report Layout Code" <> '' THEN
        EXIT(CustomReportSelection."Custom Report Layout Code");

      // If we don't have a custom layout defined in this selection record, get the default for the report number
      IF ReportLayoutSelection.GET(CustomReportSelection."Report ID",COMPANYNAME) THEN
        EXIT(ReportLayoutSelection."Custom Report Layout Code");

      EXIT(''); // We haven't found any custom report layouts
    END;

    LOCAL PROCEDURE ResolveEmailBodyLayoutCode@54(VAR CustomReportSelection@1001 : Record 9657;VAR ReportSelections@1000 : Record 77) : Code[20];
    BEGIN
      IF CustomReportSelection."Use for Email Body" THEN
        EXIT(CustomReportSelection."Email Body Layout Code");

      IF ReportSelections."Use for Email Body" THEN
        EXIT(ReportSelections."Email Body Layout Code");

      EXIT(''); // We haven't found any custom report layouts
    END;

    [Internal]
    PROCEDURE InitializeData@49(ReportSelectionUsage@1005 : Integer;VAR DataRecordRef@1004 : RecordRef;SourceJoinFieldName@1003 : Text;DataRecordJoinTable@1002 : Integer;IteratorTableFieldName@1001 : Text;DataItemTableSameAsIterator@1000 : Boolean);
    BEGIN
      // Initialize parameters and request pages, but do not run the reports yet
      SetReportUsage(ReportSelectionUsage);
      SetReportDataItem(DataRecordRef,SourceJoinFieldName,DataRecordJoinTable,IteratorTableFieldName,DataItemTableSameAsIterator);
      GetRequestParameters;
    END;

    [External]
    PROCEDURE HasRequestParameterData@50(ReportID@1000 : Integer) : Boolean;
    BEGIN
      // Allows the caller to determine if valid request parameters XML is stored for the given report ID.
      // This is mostly useful to determine if a given report's request page has been canceled or not.
      EXIT(TempBlobReqParamStore.GET(ReportID));
    END;

    LOCAL PROCEDURE GetKeyFieldRef@53(VAR TableRecordRef@1001 : RecordRef;VAR KeyFieldRef@1000 : FieldRef) : Boolean;
    VAR
      DataTypeManagement@1002 : Codeunit 701;
    BEGIN
      CASE TableRecordRef.NUMBER OF
        DATABASE::Customer,
        DATABASE::Vendor:
          BEGIN
            DataTypeManagement.FindFieldByName(TableRecordRef,KeyFieldRef,'No.');
            EXIT(TRUE);
          END;
        ELSE
          EXIT(FALSE);
      END;
    END;

    LOCAL PROCEDURE GetNameFieldRef@52(VAR TableRecordRef@1001 : RecordRef;VAR NameFieldRef@1000 : FieldRef) : Boolean;
    VAR
      DataTypeManagement@1002 : Codeunit 701;
    BEGIN
      CASE TableRecordRef.NUMBER OF
        DATABASE::Customer,
        DATABASE::Vendor:
          BEGIN
            DataTypeManagement.FindFieldByName(TableRecordRef,NameFieldRef,'Name');
            EXIT(TRUE);
          END;
        ELSE
          EXIT(FALSE);
      END;
    END;

    LOCAL PROCEDURE FindNextEmptyFilterGroup@41(VAR RecordRef@1000 : RecordRef) : Integer;
    VAR
      FilterGroup@1001 : Integer;
      StartingGroup@1002 : Integer;
    BEGIN
      // Finds the next empty filter group, with a minimum of group 10 to ensure we're in a non-system group.
      StartingGroup := RecordRef.FILTERGROUP;
      FilterGroup := StartingGroup;

      IF FilterGroup < 10 THEN
        FilterGroup := 10;

      // Find the next empty group
      RecordRef.FILTERGROUP(FilterGroup);
      IF RecordRef.HASFILTER THEN
        REPEAT
          FilterGroup += 1;
          RecordRef.FILTERGROUP(FilterGroup);
        UNTIL NOT RecordRef.HASFILTER;

      // Reset the group back to the original value
      RecordRef.FILTERGROUP(StartingGroup);

      EXIT(FilterGroup);
    END;

    LOCAL PROCEDURE SetNextGroupFilter@56(VAR RecordRef@1000 : RecordRef;VAR FieldRef@1004 : FieldRef;Filter@1001 : Text) : Integer;
    VAR
      NextGroup@1002 : Integer;
    BEGIN
      NextGroup := FindNextEmptyFilterGroup(RecordRef);
      SetGroupFilter(RecordRef,FieldRef,Filter,NextGroup);
      EXIT(NextGroup);
    END;

    LOCAL PROCEDURE SetGroupFilter@87(VAR RecordRef@1000 : RecordRef;VAR FieldRef@1001 : FieldRef;Filter@1002 : Text;GroupNumber@1003 : Integer);
    VAR
      FilterGroup@1004 : Integer;
    BEGIN
      FilterGroup := RecordRef.FILTERGROUP;
      RecordRef.FILTERGROUP(GroupNumber);
      FieldRef.SETFILTER(Filter);
      RecordRef.FILTERGROUP(FilterGroup);
    END;

    LOCAL PROCEDURE CleanupTempFiles@16();
    VAR
      DeleteError@1000 : Boolean;
    BEGIN
      // Sometimes file handles are kept by .NET - we try to delete what we can.
      IF TempEraseFileNameValueBuffer.FINDSET THEN
        REPEAT
          IF NOT TryDeleteFile(TempEraseFileNameValueBuffer.Name) THEN
            DeleteError := TRUE;
        UNTIL TempEraseFileNameValueBuffer.NEXT = 0;

      IF DeleteError THEN
        ERROR('');
    END;

    [TryFunction]
    LOCAL PROCEDURE TryDeleteFile@17(FileName@1000 : Text);
    BEGIN
      FileManagement.DeleteServerFile(FileName);
    END;

    [TryFunction]
    LOCAL PROCEDURE TryCreateFileStream@28(VAR File@1000 : File;ReportID@1003 : Integer;VAR TempFilePath@1002 : Text[250];VAR FileName@1004 : Text[250];VAR FileStream@1006 : OutStream;Extension@1005 : Text);
    VAR
      FileManagement@1001 : Codeunit 419;
    BEGIN
      TempFilePath := COPYSTR(FileManagement.ServerTempFileName(Extension),1,250);

      FileName := GenerateFileNameForReport(ReportID,Extension,'',FALSE);

      File.CREATE(TempFilePath);
      File.CREATEOUTSTREAM(FileStream);
    END;

    [TryFunction]
    LOCAL PROCEDURE TryEmailReport@39(TempFilePath@1001 : Text[250];FileName@1002 : Text[250];TempEmailBodyFilePath@1003 : Text[250];VAR CustomReportSelection@1004 : Record 9657;VAR FieldRef2@1005 : FieldRef);
    VAR
      DocumentMailing@1000 : Codeunit 260;
    BEGIN
      DocumentMailing.EmailFile(
        COPYSTR(TempFilePath,1,250),FileName,TempEmailBodyFilePath,'',CustomReportSelection."Send To Email",
        STRSUBSTNO('%1',FieldRef2.VALUE),TRUE,CustomReportSelection.Usage);
      IF EXISTS(TempFilePath) THEN
        TempEraseFileNameValueBuffer.AddNewEntry(TempFilePath,'');
      IF EXISTS(TempEmailBodyFilePath) THEN
        TempEraseFileNameValueBuffer.AddNewEntry(TempEmailBodyFilePath,'');
    END;

    LOCAL PROCEDURE CreateReportWithExtension@34(VAR DataRecRef@1001 : RecordRef;ReportID@1000 : Integer;ReportFormatType@1002 : ReportFormat;VAR FileName@1003 : Text[250]) : Text[250];
    VAR
      File@1006 : File;
      FileStream@1005 : OutStream;
      TempFilePath@1004 : Text[250];
    BEGIN
      CASE ReportFormatType OF
        REPORTFORMAT::Pdf:
          BEGIN
            TryCreateFileStream(File,ReportID,TempFilePath,FileName,FileStream,'pdf');
            TempEmailNameValueBuffer.SETRANGE(Name,FileName);
            IF NOT TempEmailNameValueBuffer.FINDFIRST THEN
              IF REPORT.SAVEAS(ReportID,GetRequestParametersText(ReportID),REPORTFORMAT::Pdf,FileStream,DataRecRef) THEN BEGIN
                TempEmailNameValueBuffer.AddNewEntry(COPYSTR(FileName,1,250),COPYSTR(TempFilePath,1,250));
                File.CLOSE;
                EXIT(TempFilePath);
              END;
            File.CLOSE;
            EXIT('');
          END;
        REPORTFORMAT::Html:
          BEGIN
            TryCreateFileStream(File,ReportID,TempFilePath,FileName,FileStream,'html');
            TempEmailNameValueBuffer.SETRANGE(Name,FileName);
            IF NOT TempEmailNameValueBuffer.FINDFIRST THEN
              IF REPORT.SAVEAS(ReportID,GetRequestParametersText(ReportID),REPORTFORMAT::Html,FileStream,DataRecRef) THEN BEGIN
                TempEmailNameValueBuffer.AddNewEntry(COPYSTR(FileName,1,250),COPYSTR(TempFilePath,1,250));
                File.CLOSE;
                EXIT(TempFilePath);
              END;
            File.CLOSE;
            EXIT('');
          END;
        ELSE
          ERROR(STRSUBSTNO(ReportFormatNotSupportedErr,ReportFormatType));
      END;
    END;

    LOCAL PROCEDURE SetIteratorJoinFieldRef@44();
    VAR
      Vendor@1000 : Record 23;
      Customer@1001 : Record 18;
      GenJournalLine@1002 : Record 81;
      IteratorTableFieldName@1003 : Text;
      i@1004 : Integer;
      DataRecordJoinTable@1005 : Integer;
    BEGIN
      BalAcctTypeFieldRef := ReportDataRecordRef.FIELD(63);
      AcctTypeFieldRef := ReportDataRecordRef.FIELD(3);

      CASE FORMAT(BalAcctTypeFieldRef.VALUE) OF
        FORMAT(GenJournalLine."Bal. Account Type"::Vendor):
          BEGIN
            DataRecordJoinTable := DATABASE::Vendor;
            IteratorTableFieldName := Vendor.FIELDNAME("No.");
          END;
        FORMAT(GenJournalLine."Bal. Account Type"::Customer):
          BEGIN
            DataRecordJoinTable := DATABASE::Customer;
            IteratorTableFieldName := Customer.FIELDNAME("No.");
          END;
        FORMAT(GenJournalLine."Bal. Account Type"::"Bank Account"):
          CASE FORMAT(AcctTypeFieldRef.VALUE) OF
            FORMAT(GenJournalLine."Account Type"::Customer):
              BEGIN
                DataRecordJoinTable := DATABASE::Customer;
                IteratorTableFieldName := Customer.FIELDNAME("No.");
              END;
            FORMAT(GenJournalLine."Account Type"::Vendor):
              BEGIN
                DataRecordJoinTable := DATABASE::Vendor;
                IteratorTableFieldName := Vendor.FIELDNAME("No.");
              END;
          END;
      END;
      IF DataRecordJoinTable <> 0 THEN BEGIN
        IteratorRecordRef.CLOSE;
        IteratorRecordRef.OPEN(DataRecordJoinTable);
        FOR i := 1 TO IteratorRecordRef.FIELDCOUNT DO
          IF IteratorRecordRef.FIELD(i).NAME = IteratorTableFieldName THEN BEGIN
            IteratorJoinFieldRef := IteratorRecordRef.FIELD(i);
            BREAK;
          END;
      END;
    END;

    LOCAL PROCEDURE GetReportRequestPageParameters@51(ReportID@1002 : Integer) XMLTxt : Text;
    VAR
      ObjectOptions@1000 : Record 2000000196;
      InStr@1001 : InStream;
    BEGIN
      IF NOT ObjectOptions.GET(LastUsedTxt,ReportID,ObjectOptions."Object Type"::Report,USERID,COMPANYNAME) THEN
        EXIT('');
      ObjectOptions.CALCFIELDS("Option Data");
      ObjectOptions."Option Data".CREATEINSTREAM(InStr);
      InStr.READTEXT(XMLTxt);
      EXIT(XMLTxt);
    END;

    LOCAL PROCEDURE SaveReportRequestPageParameters@40(ReportID@1000 : Integer;XMLText@1001 : Text);
    VAR
      ObjectOptions@1002 : Record 2000000196;
      OutStr@1003 : OutStream;
    BEGIN
      IF XMLText = '' THEN
        EXIT;

      WITH ObjectOptions DO BEGIN
        IF GET(LastUsedTxt,ReportID,"Object Type"::Report,USERID,COMPANYNAME) THEN
          DELETE;
        INIT;
        "Parameter Name" := 'Last used options and filters';
        "Object Type" := "Object Type"::Report;
        "Object ID" := ReportID;
        "User Name" := USERID;
        "Company Name" := COMPANYNAME;
        "Created By" := USERID;
        "Option Data".CREATEOUTSTREAM(OutStr);
        OutStr.WRITETEXT(XMLText);
        INSERT;
      END;
    END;

    BEGIN
    {
      This codeunit implements batch printing and custom layout association on a per-object basis.
      Reports may be based on one table, but we may want to sepcific a layout per-customer, or per-vendor.
      This codeunit provides functions to help manage the association between the table that backs the report and the object we want custom layouts on.

      Example code below, for Customer Statements, backed by Customer and associating custom reports per-Customer:

      // Get the RecordRef of the table that will source the data for our report - Statements should be backed by Customer
      RecRef.OPEN(DATABASE::Customer);
      // Set up the association between the Table that is the source of the report and the association to the table we want layouts for
      // In this case, we are using Customer for the report and Customer for the layouts.
      CustomerLayoutReporting.ProcessReport(ReportSelections.Usage::"C.Statement",RecRef,'No.',DATABASE::Customer,'No.',TRUE);
    }
    END.
  }
}

